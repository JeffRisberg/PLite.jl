<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Parallel Value Iteration &mdash; PLite.jl 1.0 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="PLite.jl 1.0 documentation" href="index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="nav-item nav-item-0"><a href="index.html">PLite.jl 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="parallel-value-iteration">
<h1>Parallel Value Iteration<a class="headerlink" href="#parallel-value-iteration" title="Permalink to this headline">Â¶</a></h1>
<p>To reap the benefits of Julia&#8217;s parallel computing framework for value iteration, we need a few more steps. The main issue we have to get around is code availability when we add processes. But we&#8217;ll skip an in-depth explanation and just go straight to what we can do.</p>
<p>We consider a quick and dirty example of running the exact same code as in the MDP with <em>T*(*s</em>, <em>a</em>) type transition on PLite&#8217;s parallel value iteration solver. First, we wrap our existing code under the module <code class="docutils literal"><span class="pre">ExampleModule</span></code> (you can name it whatever you want), and save it under the file name <code class="docutils literal"><span class="pre">ExampleModule.jl</span></code>. As our naming scheme suggests, the module and file should share the same name. Below is what should be saved to the file.</p>
<div class="highlight-python"><div class="highlight"><pre>module ExampleModule

export
  mdp,
  solver,
  solve,
  getpolicy

using PLite

# constants
const MinX = 0
const MaxX = 100
const StepX = 20

# mdp definition
mdp = MDP()

statevariable!(mdp, &quot;x&quot;, MinX, MaxX)  # continuous
statevariable!(mdp, &quot;goal&quot;, [&quot;no&quot;, &quot;yes&quot;])  # discrete

actionvariable!(mdp, &quot;move&quot;, [&quot;W&quot;, &quot;E&quot;, &quot;stop&quot;])  # discrete

transition!(mdp,
  [&quot;x&quot;, &quot;goal&quot;, &quot;move&quot;],
  function mytransition(x::Float64, goal::AbstractString, move::AbstractString)
    function isgoal(x::Float64)
      if abs(x - MaxX / 2) &lt; StepX
        return &quot;yes&quot;
      else
        return &quot;no&quot;
      end
    end

    if isgoal(x) == &quot;yes&quot; &amp;&amp; goal == &quot;yes&quot;
      return [([x, isgoal(x)], 1.0)]
    end

    if move == &quot;E&quot;
      if x &gt;= MaxX
        return [
          ([x, isgoal(x)], 0.9),
          ([x - StepX, isgoal(x - StepX)], 0.1)]
      elseif x &lt;= MinX
        return [
          ([x, isgoal(x)], 0.2),
          ([x + StepX, isgoal(x + StepX)], 0.8)]
      else
        return [
          ([x, isgoal(x)], 0.1),
          ([x - StepX, isgoal(x - StepX)], 0.1),
          ([x + StepX, isgoal(x + StepX)], 0.8)]
      end
    elseif move == &quot;W&quot;
      if x &gt;= MaxX
        return [
          ([x, isgoal(x)], 0.1),
          ([x - StepX, isgoal(x - StepX)], 0.9)]
      elseif x &lt;= MinX
        return [
        ([x, isgoal(x)], 0.9),
        ([x + StepX, isgoal(x + StepX)], 0.1)]
      else
        return [
          ([x, isgoal(x)], 0.1),
          ([x - StepX, isgoal(x - StepX)], 0.8),
          ([x + StepX, isgoal(x + StepX)], 0.1)]
      end
    elseif move == &quot;stop&quot;
      return [([x, isgoal(x)], 1.0)]
    end
  end
)

reward!(mdp,
  [&quot;x&quot;, &quot;goal&quot;, &quot;move&quot;],
  function myreward(x::Float64, goal::String, move::String)
    if goal == &quot;yes&quot; &amp;&amp; move == &quot;stop&quot;
      return 1
    else
      return 0
    end
  end
)

# solver options
solver = ParallelValueIteration()
discretize_statevariable!(solver, &quot;x&quot;, StepX)

end
</pre></div>
</div>
<p>On top of the keyword arguments available to <code class="docutils literal"><span class="pre">SerialValueIteration</span></code>, <code class="docutils literal"><span class="pre">ParallelValueIteration</span></code> has an additional <code class="docutils literal"><span class="pre">nthreads</span></code> keyword argument. The default value is <code class="docutils literal"><span class="pre">CPU_CORES</span> <span class="pre">/</span> <span class="pre">2</span></code>.</p>
<p><code class="docutils literal"><span class="pre">CPU_CORES</span></code> is a Julia standard library constant, and it defaults to the number of CPU cores in your system. But the number of cores given usually includes virtual cores (e.g., Intel processors), so we divide by two to obtain the number of physical cores. There isn&#8217;t an issue with increasing the number of cores. But since we have the same number of cores doing the same number of work, there won&#8217;t be an increase in efficiency. In fact, with greater number of threads there may be more overhead and runtime processes. As such, we recommend using as many threads as there are physical cores on the machine. In the case of the parallel solver, we can define</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">solver</span> <span class="o">=</span> <span class="n">ParallelValueIteration</span><span class="p">(</span>
  <span class="n">tol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span>
  <span class="n">maxiter</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span>
  <span class="n">discount</span><span class="o">=</span><span class="mf">0.999</span><span class="p">,</span>
  <span class="n">verbose</span><span class="o">=</span><span class="n">false</span><span class="p">,</span>
  <span class="n">nthreads</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>As in the serial solver, PLite needs a definition of the discretization scheme.</p>
<p>Notice that there are two modifications to the code being wrapped (in addition to putting it in <code class="docutils literal"><span class="pre">ExampleModule</span></code> and using <code class="docutils literal"><span class="pre">ParallelValueIteration</span></code>):</p>
<ol class="arabic simple">
<li>we removed the <code class="docutils literal"><span class="pre">solve</span></code> bit that generated the solution</li>
<li>we added the <code class="docutils literal"><span class="pre">export</span></code> keyword that makes the objects and functions available to the user (either in on the console or the Jupyter notebook)</li>
</ol>
<div class="highlight-python"><div class="highlight"><pre>export
  mdp,
  solver,
  solve,
  getpolicy
</pre></div>
</div>
<p>On the console or Jupyter notebook, we then input the following.</p>
<div class="highlight-python"><div class="highlight"><pre>const NThreads = int(CPU_CORES / 2)
addprocs(NThreads - 1)  # -1 to account for existing process

using ExampleModule

# generate results
solution = solve(mdp, solver)
</pre></div>
</div>
<p>Notice we add the desired number of processes before loading the module. This sequence of code evaluation allows all processes to get the code on ExampleModule. We then call <code class="docutils literal"><span class="pre">solve</span></code> on the mdp and solver to obtain the solution.</p>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/pvi.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2015, Hao Yi Ong.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.3</a>
      
      |
      <a href="_sources/pvi.txt"
          rel="nofollow">Page source</a></li>
    </div>

    

    
  </body>
</html>